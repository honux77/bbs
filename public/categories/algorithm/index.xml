<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Algorithm on Honux BBS</title>
    <link>http://localhost:1313/categories/algorithm/</link>
    <description>Recent content in Algorithm on Honux BBS</description>
    <generator>Hugo</generator>
    <language>ko</language>
    <lastBuildDate>Sun, 03 Jan 2021 04:12:07 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/categories/algorithm/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[알고리즘] BOJ 1022 소용돌이 예쁘게 출력하기</title>
      <link>http://localhost:1313/post/boj-1022/</link>
      <pubDate>Sun, 03 Jan 2021 04:12:07 +0000</pubDate>
      <guid>http://localhost:1313/post/boj-1022/</guid>
      <description>&lt;h2 id=&#34;만만히-봤다가-어렵게-풀었다&#34;&gt;만만히 봤다가 어렵게 풀었다.&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://www.acmicpc.net/problem/1022&#34;&gt;문제 링크&lt;/a&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;소용돌이 배열을 예쁘게 찍는 문제&lt;/li&gt;&#xA;&lt;li&gt;생각보다 많이 어렵다.&lt;/li&gt;&#xA;&lt;li&gt;무작위로 전부 다 채우면 메모리 에러가 발생한다.&lt;/li&gt;&#xA;&lt;li&gt;정확하게 주어진 출력 범위의 답만 찾아서 &lt;code&gt;예쁘게&lt;/code&gt; 출력해야 한다. 예쁘게가 꽤 어렵다.&lt;/li&gt;&#xA;&lt;li&gt;풀고 나서 다른 답안을 보니 수학적으로 getValue(i, j) 를 구해서 풀 수도 있다.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;cstdio&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;iomanip&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;vector&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;algorithm&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;namespace&lt;/span&gt; std;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; ull &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; sr &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; sc &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; v &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; delta &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; csize &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; dc &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; true;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; a[&lt;span style=&#34;color:#ae81ff&#34;&gt;50&lt;/span&gt;][&lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;];&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ios_base&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;sync_with_stdio(false);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    cin.tie(&lt;span style=&#34;color:#66d9ef&#34;&gt;nullptr&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; r1, c1, r2, c2, mr, mc;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    cin &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; r1 &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; c1 &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; r2 &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; c2;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    mr &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;r1;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    mc &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;c1;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; fillCount &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (r2 &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; r1 &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; (c2 &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; c1 &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; currentFill &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; vmax;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (currentFill &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; fillCount)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; t &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; t &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;; t&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; csize; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (sr &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; r1 &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; sr &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; r2 &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; sc &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; c1 &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; sc &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; c2)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    a[sr &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; mr][sc &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; mc] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; v;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    currentFill&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    vmax &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; v;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#75715e&#34;&gt;//cerr &amp;lt;&amp;lt; sr &amp;lt;&amp;lt; &amp;#34; &amp;#34; &amp;lt;&amp;lt; sc &amp;lt;&amp;lt; &amp;#34; &amp;#34; &amp;lt;&amp;lt; v &amp;lt;&amp;lt; &amp;#34; &amp;#34; &amp;lt;&amp;lt; currentFill &amp;lt;&amp;lt; &amp;#34;\n&amp;#34;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                v&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (dc)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    sc &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; delta;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    sr &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; delta;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            dc &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;dc;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            delta &lt;span style=&#34;color:#f92672&#34;&gt;*=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        delta &lt;span style=&#34;color:#f92672&#34;&gt;*=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        csize&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; w &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (vmax &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        vmax &lt;span style=&#34;color:#f92672&#34;&gt;/=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        w&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; r2 &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; r1; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; j &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; j &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; c2 &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; c1; j&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; setw(w) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; a[i][j] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34; &amp;#34;&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    <item>
      <title>BOJ 9205 맥주 마시면서 걸어가기</title>
      <link>http://localhost:1313/post/boj-9205/</link>
      <pubDate>Tue, 17 Nov 2020 01:45:27 +0000</pubDate>
      <guid>http://localhost:1313/post/boj-9205/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://www.acmicpc.net/problem/9205&#34;&gt;BOJ 9205&lt;/a&gt; 는 길찾기 문제이다.&#xA;정해진 기간마다 맥주를 마시면서 걷다 맥주가 부족해지기 전에 가게에 들려 맥주를 리필하고, 목적지를 찾아갈 수 있는지 여부를 출력해주면 된다.&lt;/p&gt;&#xA;&lt;h2 id=&#34;풀이&#34;&gt;풀이&lt;/h2&gt;&#xA;&lt;p&gt;맥주가 떨어지기 전에 갈 수 있는 최대거리는 1000미터이므로 BFS를 이용해서 1000미터 이내의 슈퍼를 방문하고 목적지까지 갈 수 있는지 여부를 확인하는 방법을 풀었다.&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;using namespace std;&#xD;&#xA;&#xD;&#xA;bool canWalk(pair&amp;lt;int,int&amp;gt; &amp;amp;a, pair&amp;lt;int,int&amp;gt; &amp;amp;b) {&#xD;&#xA;    return abs(a.first - b.first) + abs(a.second - b.second) &amp;lt;= 1000;&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;void bfs(vector&amp;lt;pair&amp;lt;int,int&amp;gt;&amp;gt; &amp;amp;a) {&#xD;&#xA;    vector&amp;lt;bool&amp;gt; visited(a.size());&#xD;&#xA;    queue &amp;lt;int&amp;gt; q;&#xD;&#xA;    q.push(0);&#xD;&#xA;&#xD;&#xA;    while(!q.empty()) {&#xD;&#xA;        int curr = q.front();&#xD;&#xA;        q.pop();&#xD;&#xA;        visited[curr] = true;&#xD;&#xA;        for (int i = 1; i &amp;lt; a.size(); i++) {&#xD;&#xA;            if (!visited[i] &amp;amp;&amp;amp; canWalk(a[curr], a[i])) {&#xD;&#xA;                if (i == a.size() - 1) {&#xD;&#xA;                    cout &amp;lt;&amp;lt; &amp;#34;happy\n&amp;#34;;&#xD;&#xA;                    return;&#xD;&#xA;                }&#xD;&#xA;                q.push(i);&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;    cout &amp;lt;&amp;lt; &amp;#34;sad\n&amp;#34;;&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;int main()&#xD;&#xA;{&#xD;&#xA;    ios_base::sync_with_stdio(false);&#xD;&#xA;    cin.tie(nullptr);&#xD;&#xA;    &#xD;&#xA;    int t;&#xD;&#xA;    cin &amp;gt;&amp;gt; t;&#xD;&#xA;    while (t--) {&#xD;&#xA;        int n;&#xD;&#xA;        cin &amp;gt;&amp;gt; n;&#xD;&#xA;        &#xD;&#xA;        vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; a(n + 2);&#xD;&#xA;&#xD;&#xA;        for (int i = 0; i &amp;lt; n + 2; i++) {&#xD;&#xA;            cin &amp;gt;&amp;gt; a[i].first &amp;gt;&amp;gt; a[i].second;       &#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        bfs(a);        &#xD;&#xA;    };&#xD;&#xA;    &#xD;&#xA;    return 0;&#xD;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;회고&#34;&gt;회고&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;왜맞틀(왜 맞았는데 틀렸다고 하지?)가 나왔는데 각 테스트케이스마다 초기화를 잊었다. 실수하지 말자.&lt;/li&gt;&#xA;&lt;li&gt;BFS를 예전보다 좀 더 빠르게 구현하게 되었다. 하지만 여전히 약간씩 실수하는 경향이 있다.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;todo&#34;&gt;TODO&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;다익스트라나 플로이드-와샬로 풀어보자. 예전에는 두 알고리즘을 종종 사용했었는데, 최근에는 더 구현이 쉬운 BFS나 DFS로 풀리는 문제는 둘 중 하나로 풀 다 보니 빠른 구현이 어려워졌다.&lt;/li&gt;&#xA;&lt;li&gt;문제를 풀기 전에 복잡도를 생각해 보는 연습도 필요한 것 같다.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;다른-풀이&#34;&gt;다른 풀이&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://barefoot-coder.tistory.com/35&#34;&gt;구글링으로 나온 블로그&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>[알고리즘] BOJ 5525 IOIOI </title>
      <link>http://localhost:1313/post/boj-5525-ioioi/</link>
      <pubDate>Fri, 06 Nov 2020 01:56:58 +0000</pubDate>
      <guid>http://localhost:1313/post/boj-5525-ioioi/</guid>
      <description>&lt;h2 id=&#34;kmp를-이용한-문자열-패턴-매칭&#34;&gt;KMP를 이용한 문자열 패턴 매칭&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://www.acmicpc.net/problem/5525&#34; title=&#34;https://www.acmicpc.net/problem/5525&#34;&gt;https://www.acmicpc.net/problem/5525&lt;/a&gt; 문제는 상당히 재미있는 문제였다.&lt;/p&gt;&#xA;&lt;h3 id=&#34;try-1&#34;&gt;Try 1&lt;/h3&gt;&#xA;&lt;p&gt;언뜻 보면 단순 문자열 비교를 통해서 풀 수 있을 것 같은 문제라 그렇게 풀어 보았다.&lt;/p&gt;&#xA;&lt;p&gt;생각해 보면 복잡도가 &lt;code&gt;O(n * m)&lt;/code&gt; 이기 때문에 당연히 TE (시간초과) 가 발생한다.&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;using namespace std;&#xD;&#xA;&#xD;&#xA;string pstr(int n) {&#xD;&#xA;    string o = &amp;#34;IO&amp;#34;;&#xD;&#xA;    string ans = &amp;#34;&amp;#34;;&#xD;&#xA;    for (int i = 0; i &amp;lt; n; i++) {&#xD;&#xA;        ans += o;&#xD;&#xA;    }&#xD;&#xA;    return ans + &amp;#34;I&amp;#34;;&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;int main()&#xD;&#xA;{&#xD;&#xA;    ios_base::sync_with_stdio(false);&#xD;&#xA;    cin.tie(nullptr);&#xD;&#xA;    &#xD;&#xA;    int n, l;&#xD;&#xA;    int ans = 0;&#xD;&#xA;    string s;&#xD;&#xA;    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; l;&#xD;&#xA;    cin &amp;gt;&amp;gt; s;&#xD;&#xA;    int psize = 2 * n + 1;&#xD;&#xA;    string pn = pstr(n);&#xD;&#xA;    &#xD;&#xA;    for (int i = 0; i &amp;lt; s.size() - psize; i++) {&#xD;&#xA;        if (s.substr(i, psize) == pn) ans++;        &#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; &amp;#34;\n&amp;#34;;&#xD;&#xA;    return 0;&#xD;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;try-2&#34;&gt;Try 2&lt;/h3&gt;&#xA;&lt;p&gt;결국 문자열 비교의 정석 KMP를 변형해서 적용했다. 비교대상 문자열이 일정하기 때문에 원래의 KMP보다 구현이 쉽다. KMP는 종만북 20장 즈음에도 나왔던 것 같은데, 문자열 문제가 종종 코딩 테스트에도 나오므로 숙지하면 좋을 것 같다. 개인적으로 KMP 알고리즘은 어렵지 않은데 실패함수를 효율적으로 구현하는 게 더 어려운 느낌이다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>BOJ 1927 최소 힙</title>
      <link>http://localhost:1313/post/boj-1927/</link>
      <pubDate>Mon, 19 Oct 2020 23:09:08 +0000</pubDate>
      <guid>http://localhost:1313/post/boj-1927/</guid>
      <description>&lt;h2 id=&#34;boj-1927-최소-힙&#34;&gt;BOJ 1927 최소 힙&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://www.acmicpc.net/problem/1927&#34;&gt;BOJ 1927&lt;/a&gt;은 말 그대로 최소 힙을 구현하는 문제다.&lt;/p&gt;&#xA;&lt;h2 id=&#34;풀이-1-stl-사용&#34;&gt;풀이 1: STL 사용&lt;/h2&gt;&#xA;&lt;p&gt;cpp에서 min(max) heap은 &lt;code&gt;priority_queue&lt;/code&gt;를 이용하면 된다.&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#include &amp;lt;cstdio&amp;gt;&#xD;&#xA;#include &amp;lt;iostream&amp;gt;&#xD;&#xA;#include &amp;lt;algorithm&amp;gt;&#xD;&#xA;#include &amp;lt;queue&amp;gt;&#xD;&#xA;&#xD;&#xA;using namespace std;&#xD;&#xA;using ull = long long int;&#xD;&#xA;&#xD;&#xA;int main()&#xD;&#xA;{&#xD;&#xA;    ios_base::sync_with_stdio(false);&#xD;&#xA;    cin.tie(nullptr);&#xD;&#xA;    &#xD;&#xA;    priority_queue&amp;lt;int, vector&amp;lt;int&amp;gt;, greater&amp;lt;int&amp;gt;&amp;gt; q;&#xD;&#xA;&#xD;&#xA;    int n;&#xD;&#xA;    cin &amp;gt;&amp;gt; n;&#xD;&#xA;    for (int i = 0; i &amp;lt; n; i++) {&#xD;&#xA;        int num;&#xD;&#xA;        cin &amp;gt;&amp;gt; num;&#xD;&#xA;        if (num == 0) {&#xD;&#xA;            if (q.size() == 0) {&#xD;&#xA;                cout &amp;lt;&amp;lt; &amp;#34;0\n&amp;#34;;&#xD;&#xA;            } else {&#xD;&#xA;                cout &amp;lt;&amp;lt; q.top() &amp;lt;&amp;lt; &amp;#34;\n&amp;#34;;&#xD;&#xA;                q.pop();&#xD;&#xA;            }&#xD;&#xA;        } else {&#xD;&#xA;            q.push(num);&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;    return 0;&#xD;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;풀이-2-직접-구현&#34;&gt;풀이 2: 직접 구현&lt;/h2&gt;&#xA;&lt;p&gt;재미삼아 직접 구현을 해 보았다. 잘 돌아가다니 신기!&lt;/p&gt;</description>
    </item>
    <item>
      <title>알고리즘 - BOJ 10814 나이순 정렬</title>
      <link>http://localhost:1313/post/algorithm-200929/</link>
      <pubDate>Tue, 29 Sep 2020 13:13:00 +0900</pubDate>
      <guid>http://localhost:1313/post/algorithm-200929/</guid>
      <description>&lt;h2 id=&#34;boj&#34;&gt;BOJ&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://www.acmicpc.net/problem/10814&#34;&gt;BOJ 10814 나이순 정렬&lt;/a&gt; 문제는 간단한 정렬문제이다.&lt;/p&gt;&#xA;&lt;p&gt;다만 기본 정렬인 퀵정렬은 불안전 정렬이기 때문에 안정정렬을 사용해야 한다.&lt;/p&gt;&#xA;&lt;h2 id=&#34;실패-분석&#34;&gt;실패 분석&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;출력이 많은데 endl을 사용하면 시간초과가 발생한다.&lt;/li&gt;&#xA;&lt;li&gt;그 사실을 모르고 복잡도 때문인지 알고 카운팅 소트를 구현해서 사용했다.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;안정-정렬-구현-코드&#34;&gt;안정 정렬 구현 코드&lt;/h2&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#include &amp;lt;cstdio&amp;gt;&#xD;&#xA;#include &amp;lt;iostream&amp;gt;&#xD;&#xA;#include &amp;lt;vector&amp;gt;&#xD;&#xA;#include &amp;lt;string&amp;gt;&#xD;&#xA;#include &amp;lt;algorithm&amp;gt;&#xD;&#xA;&#xD;&#xA;using namespace std;&#xD;&#xA;using i64 = long long int;&#xD;&#xA;&#xD;&#xA;struct People {&#xD;&#xA;        int age;&#xD;&#xA;        string name;&#xD;&#xA;};&#xD;&#xA;&#xD;&#xA;bool cmp(const People &amp;amp;a, const People &amp;amp;b) {&#xD;&#xA;        return a.age &amp;lt; b.age;&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;int main()&#xD;&#xA;{&#xD;&#xA;    ios_base::sync_with_stdio(false);&#xD;&#xA;    cin.tie(nullptr);&#xD;&#xA;&#xD;&#xA;    int n;&#xD;&#xA;    cin &amp;gt;&amp;gt; n;&#xD;&#xA;        vector &amp;lt;People&amp;gt; a(n);&#xD;&#xA;        for (int i = 0; i &amp;lt; n; i++) {&#xD;&#xA;                People p;&#xD;&#xA;                cin &amp;gt;&amp;gt; p.age &amp;gt;&amp;gt; p.name;&#xD;&#xA;                a[i] = p;&#xD;&#xA;        }&#xD;&#xA;        stable_sort(a.begin(), a.end(), cmp);&#xD;&#xA;&#xD;&#xA;        for (int i = 0; i &amp;lt; n; i++) {&#xD;&#xA;                cout &amp;lt;&amp;lt; a[i].age &amp;lt;&amp;lt; &amp;#34; &amp;#34; &amp;lt;&amp;lt; a[i].name &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;&#xD;&#xA;        }&#xD;&#xA;    return 0;&#xD;&#xA;}%   &#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;카운팅-소트-구현-코드&#34;&gt;카운팅 소트 구현 코드&lt;/h2&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#include &amp;lt;cstdio&amp;gt;&#xD;&#xA;#include &amp;lt;iostream&amp;gt;&#xD;&#xA;#include &amp;lt;vector&amp;gt;&#xD;&#xA;#include &amp;lt;string&amp;gt;&#xD;&#xA;#include &amp;lt;algorithm&amp;gt;&#xD;&#xA;&#xD;&#xA;using namespace std;&#xD;&#xA;using i64 = long long int;&#xD;&#xA;&#xD;&#xA;int main()&#xD;&#xA;{&#xD;&#xA;    ios_base::sync_with_stdio(false);&#xD;&#xA;    cin.tie(nullptr);&#xD;&#xA;&#xD;&#xA;    int n;&#xD;&#xA;    cin &amp;gt;&amp;gt; n;&#xD;&#xA;        vector &amp;lt;vector &amp;lt;string&amp;gt;&amp;gt; v(201);&#xD;&#xA;&#xD;&#xA;        for (int i = 0; i &amp;lt; n; i++) {&#xD;&#xA;                int age;&#xD;&#xA;                string name;&#xD;&#xA;                cin &amp;gt;&amp;gt; age &amp;gt;&amp;gt; name;&#xD;&#xA;                v[age].push_back(name);&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        for (int i = 1; i &amp;lt;= 200; i++) {&#xD;&#xA;                if (v[i].size() != 0) {&#xD;&#xA;                        for (auto &amp;amp;name: v[i]) {&#xD;&#xA;                                cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;#34; &amp;#34; &amp;lt;&amp;lt; name &amp;lt;&amp;lt; &amp;#34;\n&amp;#34;;&#xD;&#xA;                        }&#xD;&#xA;                }&#xD;&#xA;        }&#xD;&#xA;    return 0;&#xD;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;난이도&#34;&gt;난이도&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;체감 난이도 2점. 쉬운 편이다.&lt;/li&gt;&#xA;&lt;li&gt;BOJ 난이도: 실버 5. 쉬운 편&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>알고리즘 - BOJ 10972 다음 순열</title>
      <link>http://localhost:1313/post/algorithm-200905/</link>
      <pubDate>Sat, 05 Sep 2020 15:23:57 +0900</pubDate>
      <guid>http://localhost:1313/post/algorithm-200905/</guid>
      <description>&lt;h2 id=&#34;boj&#34;&gt;BOJ&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://www.acmicpc.net/problem/10972&#34;&gt;BOJ 10972  다음 순열&lt;/a&gt; 문제는 말 그대로 사전순으로 다음 순열을 찾는 문제다.&lt;/p&gt;&#xA;&lt;p&gt;일종의 Brute force 문제인데, 구현이 쉽지 않았다.&lt;/p&gt;&#xA;&lt;h2 id=&#34;아이디어&#34;&gt;아이디어&lt;/h2&gt;&#xA;&lt;h3 id=&#34;단계-1&#34;&gt;단계 1&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;역순 정렬되어 있으면 다음 순열이 없으므로  -1 을 출력한다.&lt;/li&gt;&#xA;&lt;li&gt;처음 바꿔야 하는 숫자를 뒤에서 앞으로 순회하며 찾는다.&lt;/li&gt;&#xA;&lt;li&gt;대상은 자신의 값이 뒷자리보다 작은 숫자&lt;/li&gt;&#xA;&lt;li&gt;예1: 1, 2, 3, [4], 5 라면 4가 해당&lt;/li&gt;&#xA;&lt;li&gt;예2: 1, [2], 5, 4, 3 이라면 2가 해당&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;단계-2&#34;&gt;단계 2&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;이번에는 찾은 숫자 a와 바꿀 숫자 b를 다시 뒤에서부터 찾는다.&lt;/li&gt;&#xA;&lt;li&gt;바꿀 숫자b는 처음으로 나오는 a보다 큰 수 이다.&lt;/li&gt;&#xA;&lt;li&gt;예1: 1, 2, 3, [4], [5] 라면 a = 4, b = 5&lt;/li&gt;&#xA;&lt;li&gt;예2: 1, [2], 5, 4, [3] 이라면 a = 2, b = 3&lt;/li&gt;&#xA;&lt;li&gt;예3: 1, [3], 5, [4], 2 이라면 a = 3, b = 4&lt;/li&gt;&#xA;&lt;li&gt;찾은 두 수 a, b를 스왑한다.&lt;/li&gt;&#xA;&lt;li&gt;예1: 1, 2, 3, [4], [5] 라면 1, 2, 3, [5], [4]&lt;/li&gt;&#xA;&lt;li&gt;예2: 1, [2], 5, 4, [3] 이라면 1, [3], 5, 4, [2]&lt;/li&gt;&#xA;&lt;li&gt;예3: 1, [3], 5, [4], 2 이라면 1, [4], 5, [3], 2&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;단계-3&#34;&gt;단계 3&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;이 부분은 사실 이유는 모르지만 그렇데 된다는 것을 풀다가 알았다.&lt;/li&gt;&#xA;&lt;li&gt;단계 2를 마치고 나면 a의 뒷자리는 항상 가장 큰 수가 된다.&lt;/li&gt;&#xA;&lt;li&gt;그래서 a의 뒷자리를 뒤집어 주면 된다.&lt;/li&gt;&#xA;&lt;li&gt;1, 2, 3, 4, 5 -&amp;gt; 1, 2, 3, 5, 4 (완성)&lt;/li&gt;&#xA;&lt;li&gt;1, 2, 5, 4, 3 -&amp;gt; 1, 3, [5, 4, 2] -&amp;gt; 1, 3, [2, 4, 5]&lt;/li&gt;&#xA;&lt;li&gt;1, 3, 5, 4, 2 -&amp;gt; 1, 4, [5, 3, 2] -&amp;gt; 1, 4, [2, 3, 5]&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;코드&#34;&gt;코드&lt;/h3&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;import sys&#xD;&#xA;&#xD;&#xA;n = int(input())&#xD;&#xA;a = list(map(int, input().split()))&#xD;&#xA;for i in range(n - 2, -1, -1):&#xD;&#xA;    if a[i] &amp;lt; a[i + 1]:&#xD;&#xA;        break&#xD;&#xA;else:&#xD;&#xA;    print(-1)&#xD;&#xA;    sys.exit(0)&#xD;&#xA;&#xD;&#xA;j = n - 1&#xD;&#xA;while a[i] &amp;gt;= a[j]:&#xD;&#xA;    j -= 1&#xD;&#xA;&#xD;&#xA;a[i], a[j] = a[j], a[i]&#xD;&#xA;&#xD;&#xA;i += 1&#xD;&#xA;j = n - 1&#xD;&#xA;&#xD;&#xA;while i &amp;lt; j:&#xD;&#xA;    a[i], a[j] = a[j], a[i]    &#xD;&#xA;    i += 1&#xD;&#xA;    j -= 1&#xD;&#xA;&#xD;&#xA;print(&amp;#34; &amp;#34;.join(map(str, a)))&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;난이도&#34;&gt;난이도&lt;/h3&gt;&#xA;&lt;p&gt;3점. 개인적으로 어려웠다.&#xA;BOJ 난이도는 실버 3. 쉬운 편&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
