<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Kmp on Honux BBS</title>
    <link>http://localhost:1313/tags/kmp/</link>
    <description>Recent content in Kmp on Honux BBS</description>
    <generator>Hugo</generator>
    <language>ko</language>
    <lastBuildDate>Fri, 06 Nov 2020 01:56:58 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/kmp/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[알고리즘] BOJ 5525 IOIOI </title>
      <link>http://localhost:1313/post/boj-5525-ioioi/</link>
      <pubDate>Fri, 06 Nov 2020 01:56:58 +0000</pubDate>
      <guid>http://localhost:1313/post/boj-5525-ioioi/</guid>
      <description>&lt;h2 id=&#34;kmp를-이용한-문자열-패턴-매칭&#34;&gt;KMP를 이용한 문자열 패턴 매칭&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://www.acmicpc.net/problem/5525&#34; title=&#34;https://www.acmicpc.net/problem/5525&#34;&gt;https://www.acmicpc.net/problem/5525&lt;/a&gt; 문제는 상당히 재미있는 문제였다.&lt;/p&gt;&#xA;&lt;h3 id=&#34;try-1&#34;&gt;Try 1&lt;/h3&gt;&#xA;&lt;p&gt;언뜻 보면 단순 문자열 비교를 통해서 풀 수 있을 것 같은 문제라 그렇게 풀어 보았다.&lt;/p&gt;&#xA;&lt;p&gt;생각해 보면 복잡도가 &lt;code&gt;O(n * m)&lt;/code&gt; 이기 때문에 당연히 TE (시간초과) 가 발생한다.&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;using namespace std;&#xD;&#xA;&#xD;&#xA;string pstr(int n) {&#xD;&#xA;    string o = &amp;#34;IO&amp;#34;;&#xD;&#xA;    string ans = &amp;#34;&amp;#34;;&#xD;&#xA;    for (int i = 0; i &amp;lt; n; i++) {&#xD;&#xA;        ans += o;&#xD;&#xA;    }&#xD;&#xA;    return ans + &amp;#34;I&amp;#34;;&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;int main()&#xD;&#xA;{&#xD;&#xA;    ios_base::sync_with_stdio(false);&#xD;&#xA;    cin.tie(nullptr);&#xD;&#xA;    &#xD;&#xA;    int n, l;&#xD;&#xA;    int ans = 0;&#xD;&#xA;    string s;&#xD;&#xA;    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; l;&#xD;&#xA;    cin &amp;gt;&amp;gt; s;&#xD;&#xA;    int psize = 2 * n + 1;&#xD;&#xA;    string pn = pstr(n);&#xD;&#xA;    &#xD;&#xA;    for (int i = 0; i &amp;lt; s.size() - psize; i++) {&#xD;&#xA;        if (s.substr(i, psize) == pn) ans++;        &#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; &amp;#34;\n&amp;#34;;&#xD;&#xA;    return 0;&#xD;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;try-2&#34;&gt;Try 2&lt;/h3&gt;&#xA;&lt;p&gt;결국 문자열 비교의 정석 KMP를 변형해서 적용했다. 비교대상 문자열이 일정하기 때문에 원래의 KMP보다 구현이 쉽다. KMP는 종만북 20장 즈음에도 나왔던 것 같은데, 문자열 문제가 종종 코딩 테스트에도 나오므로 숙지하면 좋을 것 같다. 개인적으로 KMP 알고리즘은 어렵지 않은데 실패함수를 효율적으로 구현하는 게 더 어려운 느낌이다.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
