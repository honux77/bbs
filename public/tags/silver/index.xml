<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Silver on Honux BBS</title>
    <link>http://localhost:1313/tags/silver/</link>
    <description>Recent content in Silver on Honux BBS</description>
    <generator>Hugo</generator>
    <language>ko</language>
    <lastBuildDate>Tue, 29 Sep 2020 13:13:00 +0900</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/silver/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>알고리즘 - BOJ 10814 나이순 정렬</title>
      <link>http://localhost:1313/post/algorithm-200929/</link>
      <pubDate>Tue, 29 Sep 2020 13:13:00 +0900</pubDate>
      <guid>http://localhost:1313/post/algorithm-200929/</guid>
      <description>&lt;h2 id=&#34;boj&#34;&gt;BOJ&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://www.acmicpc.net/problem/10814&#34;&gt;BOJ 10814 나이순 정렬&lt;/a&gt; 문제는 간단한 정렬문제이다.&lt;/p&gt;&#xA;&lt;p&gt;다만 기본 정렬인 퀵정렬은 불안전 정렬이기 때문에 안정정렬을 사용해야 한다.&lt;/p&gt;&#xA;&lt;h2 id=&#34;실패-분석&#34;&gt;실패 분석&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;출력이 많은데 endl을 사용하면 시간초과가 발생한다.&lt;/li&gt;&#xA;&lt;li&gt;그 사실을 모르고 복잡도 때문인지 알고 카운팅 소트를 구현해서 사용했다.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;안정-정렬-구현-코드&#34;&gt;안정 정렬 구현 코드&lt;/h2&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#include &amp;lt;cstdio&amp;gt;&#xD;&#xA;#include &amp;lt;iostream&amp;gt;&#xD;&#xA;#include &amp;lt;vector&amp;gt;&#xD;&#xA;#include &amp;lt;string&amp;gt;&#xD;&#xA;#include &amp;lt;algorithm&amp;gt;&#xD;&#xA;&#xD;&#xA;using namespace std;&#xD;&#xA;using i64 = long long int;&#xD;&#xA;&#xD;&#xA;struct People {&#xD;&#xA;        int age;&#xD;&#xA;        string name;&#xD;&#xA;};&#xD;&#xA;&#xD;&#xA;bool cmp(const People &amp;amp;a, const People &amp;amp;b) {&#xD;&#xA;        return a.age &amp;lt; b.age;&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;int main()&#xD;&#xA;{&#xD;&#xA;    ios_base::sync_with_stdio(false);&#xD;&#xA;    cin.tie(nullptr);&#xD;&#xA;&#xD;&#xA;    int n;&#xD;&#xA;    cin &amp;gt;&amp;gt; n;&#xD;&#xA;        vector &amp;lt;People&amp;gt; a(n);&#xD;&#xA;        for (int i = 0; i &amp;lt; n; i++) {&#xD;&#xA;                People p;&#xD;&#xA;                cin &amp;gt;&amp;gt; p.age &amp;gt;&amp;gt; p.name;&#xD;&#xA;                a[i] = p;&#xD;&#xA;        }&#xD;&#xA;        stable_sort(a.begin(), a.end(), cmp);&#xD;&#xA;&#xD;&#xA;        for (int i = 0; i &amp;lt; n; i++) {&#xD;&#xA;                cout &amp;lt;&amp;lt; a[i].age &amp;lt;&amp;lt; &amp;#34; &amp;#34; &amp;lt;&amp;lt; a[i].name &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;&#xD;&#xA;        }&#xD;&#xA;    return 0;&#xD;&#xA;}%   &#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;카운팅-소트-구현-코드&#34;&gt;카운팅 소트 구현 코드&lt;/h2&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#include &amp;lt;cstdio&amp;gt;&#xD;&#xA;#include &amp;lt;iostream&amp;gt;&#xD;&#xA;#include &amp;lt;vector&amp;gt;&#xD;&#xA;#include &amp;lt;string&amp;gt;&#xD;&#xA;#include &amp;lt;algorithm&amp;gt;&#xD;&#xA;&#xD;&#xA;using namespace std;&#xD;&#xA;using i64 = long long int;&#xD;&#xA;&#xD;&#xA;int main()&#xD;&#xA;{&#xD;&#xA;    ios_base::sync_with_stdio(false);&#xD;&#xA;    cin.tie(nullptr);&#xD;&#xA;&#xD;&#xA;    int n;&#xD;&#xA;    cin &amp;gt;&amp;gt; n;&#xD;&#xA;        vector &amp;lt;vector &amp;lt;string&amp;gt;&amp;gt; v(201);&#xD;&#xA;&#xD;&#xA;        for (int i = 0; i &amp;lt; n; i++) {&#xD;&#xA;                int age;&#xD;&#xA;                string name;&#xD;&#xA;                cin &amp;gt;&amp;gt; age &amp;gt;&amp;gt; name;&#xD;&#xA;                v[age].push_back(name);&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        for (int i = 1; i &amp;lt;= 200; i++) {&#xD;&#xA;                if (v[i].size() != 0) {&#xD;&#xA;                        for (auto &amp;amp;name: v[i]) {&#xD;&#xA;                                cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;#34; &amp;#34; &amp;lt;&amp;lt; name &amp;lt;&amp;lt; &amp;#34;\n&amp;#34;;&#xD;&#xA;                        }&#xD;&#xA;                }&#xD;&#xA;        }&#xD;&#xA;    return 0;&#xD;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;난이도&#34;&gt;난이도&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;체감 난이도 2점. 쉬운 편이다.&lt;/li&gt;&#xA;&lt;li&gt;BOJ 난이도: 실버 5. 쉬운 편&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>알고리즘 - BOJ 10972 다음 순열</title>
      <link>http://localhost:1313/post/algorithm-200905/</link>
      <pubDate>Sat, 05 Sep 2020 15:23:57 +0900</pubDate>
      <guid>http://localhost:1313/post/algorithm-200905/</guid>
      <description>&lt;h2 id=&#34;boj&#34;&gt;BOJ&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://www.acmicpc.net/problem/10972&#34;&gt;BOJ 10972  다음 순열&lt;/a&gt; 문제는 말 그대로 사전순으로 다음 순열을 찾는 문제다.&lt;/p&gt;&#xA;&lt;p&gt;일종의 Brute force 문제인데, 구현이 쉽지 않았다.&lt;/p&gt;&#xA;&lt;h2 id=&#34;아이디어&#34;&gt;아이디어&lt;/h2&gt;&#xA;&lt;h3 id=&#34;단계-1&#34;&gt;단계 1&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;역순 정렬되어 있으면 다음 순열이 없으므로  -1 을 출력한다.&lt;/li&gt;&#xA;&lt;li&gt;처음 바꿔야 하는 숫자를 뒤에서 앞으로 순회하며 찾는다.&lt;/li&gt;&#xA;&lt;li&gt;대상은 자신의 값이 뒷자리보다 작은 숫자&lt;/li&gt;&#xA;&lt;li&gt;예1: 1, 2, 3, [4], 5 라면 4가 해당&lt;/li&gt;&#xA;&lt;li&gt;예2: 1, [2], 5, 4, 3 이라면 2가 해당&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;단계-2&#34;&gt;단계 2&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;이번에는 찾은 숫자 a와 바꿀 숫자 b를 다시 뒤에서부터 찾는다.&lt;/li&gt;&#xA;&lt;li&gt;바꿀 숫자b는 처음으로 나오는 a보다 큰 수 이다.&lt;/li&gt;&#xA;&lt;li&gt;예1: 1, 2, 3, [4], [5] 라면 a = 4, b = 5&lt;/li&gt;&#xA;&lt;li&gt;예2: 1, [2], 5, 4, [3] 이라면 a = 2, b = 3&lt;/li&gt;&#xA;&lt;li&gt;예3: 1, [3], 5, [4], 2 이라면 a = 3, b = 4&lt;/li&gt;&#xA;&lt;li&gt;찾은 두 수 a, b를 스왑한다.&lt;/li&gt;&#xA;&lt;li&gt;예1: 1, 2, 3, [4], [5] 라면 1, 2, 3, [5], [4]&lt;/li&gt;&#xA;&lt;li&gt;예2: 1, [2], 5, 4, [3] 이라면 1, [3], 5, 4, [2]&lt;/li&gt;&#xA;&lt;li&gt;예3: 1, [3], 5, [4], 2 이라면 1, [4], 5, [3], 2&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;단계-3&#34;&gt;단계 3&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;이 부분은 사실 이유는 모르지만 그렇데 된다는 것을 풀다가 알았다.&lt;/li&gt;&#xA;&lt;li&gt;단계 2를 마치고 나면 a의 뒷자리는 항상 가장 큰 수가 된다.&lt;/li&gt;&#xA;&lt;li&gt;그래서 a의 뒷자리를 뒤집어 주면 된다.&lt;/li&gt;&#xA;&lt;li&gt;1, 2, 3, 4, 5 -&amp;gt; 1, 2, 3, 5, 4 (완성)&lt;/li&gt;&#xA;&lt;li&gt;1, 2, 5, 4, 3 -&amp;gt; 1, 3, [5, 4, 2] -&amp;gt; 1, 3, [2, 4, 5]&lt;/li&gt;&#xA;&lt;li&gt;1, 3, 5, 4, 2 -&amp;gt; 1, 4, [5, 3, 2] -&amp;gt; 1, 4, [2, 3, 5]&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;코드&#34;&gt;코드&lt;/h3&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;import sys&#xD;&#xA;&#xD;&#xA;n = int(input())&#xD;&#xA;a = list(map(int, input().split()))&#xD;&#xA;for i in range(n - 2, -1, -1):&#xD;&#xA;    if a[i] &amp;lt; a[i + 1]:&#xD;&#xA;        break&#xD;&#xA;else:&#xD;&#xA;    print(-1)&#xD;&#xA;    sys.exit(0)&#xD;&#xA;&#xD;&#xA;j = n - 1&#xD;&#xA;while a[i] &amp;gt;= a[j]:&#xD;&#xA;    j -= 1&#xD;&#xA;&#xD;&#xA;a[i], a[j] = a[j], a[i]&#xD;&#xA;&#xD;&#xA;i += 1&#xD;&#xA;j = n - 1&#xD;&#xA;&#xD;&#xA;while i &amp;lt; j:&#xD;&#xA;    a[i], a[j] = a[j], a[i]    &#xD;&#xA;    i += 1&#xD;&#xA;    j -= 1&#xD;&#xA;&#xD;&#xA;print(&amp;#34; &amp;#34;.join(map(str, a)))&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;난이도&#34;&gt;난이도&lt;/h3&gt;&#xA;&lt;p&gt;3점. 개인적으로 어려웠다.&#xA;BOJ 난이도는 실버 3. 쉬운 편&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
