<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Javascript on Honux BBS</title>
    <link>http://localhost:1313/tags/javascript/</link>
    <description>Recent content in Javascript on Honux BBS</description>
    <generator>Hugo</generator>
    <language>ko</language>
    <lastBuildDate>Tue, 15 Dec 2020 16:11:07 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/javascript/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>JS 클래스와 TS static 키워드에 대한 짧은 고찰</title>
      <link>http://localhost:1313/post/js-ts-static/</link>
      <pubDate>Tue, 15 Dec 2020 16:11:07 +0000</pubDate>
      <guid>http://localhost:1313/post/js-ts-static/</guid>
      <description>&lt;p&gt;요즘 인프런 캡틴 팡요님의 TS강의를 듣고 있다가 생각나서 짧게 정리해 보았다.&lt;/p&gt;&#xA;&lt;p&gt;예전에 ES6의 클래스 문법을 사용하면서, 기존 자바에서 사용하던 static 메소드와 static 변수를 사용하고 싶었는데, 잘 되지 않았던 기억이 있었다.&lt;/p&gt;&#xA;&lt;p&gt;이 문제를 해결하기 위한 아이디어가 갑자기 떠올랐는데, TS로 코딩을 하고 컴파일을 해서 생성된 코드를 보는 것이다!&lt;/p&gt;&#xA;&lt;p&gt;먼저 TS에는 당연히 static 메소드와 static 변수가 있으니까 이를 이용해서 코드를 짜 보았다.&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;class Dog {&#xD;&#xA;    public name: string;&#xD;&#xA;    private age: number;&#xD;&#xA;    public static numTail: number;&#xD;&#xA;&#xD;&#xA;    constructor(name, age) {&#xD;&#xA;        this.name = name;&#xD;&#xA;        this.age = age;&#xD;&#xA;        Dog.numTail = 1;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    hi(): void {&#xD;&#xA;      console.log(`Hello I am ${this.name} and I am ${this.age} years old`);  &#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    static wow(): void {&#xD;&#xA;        console.log(`We are Dogs and We have ${Dog.numTail} tail(s)!`);&#xD;&#xA;    }&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;function foo(d: Dog) : void {&#xD;&#xA;    d.hi();&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;const d1 = new Dog(&amp;#39;Nabi&amp;#39;, 3);&#xD;&#xA;const d2 = new Dog(&amp;#39;Zelda&amp;#39;, 10);&#xD;&#xA;&#xD;&#xA;foo(d1);&#xD;&#xA;d2.hi();&#xD;&#xA;Dog.wow();&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;이제 컴파일하고 실행을 해 보자.&lt;/p&gt;</description>
    </item>
    <item>
      <title>RFC 읽고 GitHub Oauth2 인증 구현해 보기</title>
      <link>http://localhost:1313/post/rfc-github-oauth2/</link>
      <pubDate>Mon, 16 Nov 2020 12:35:47 +0000</pubDate>
      <guid>http://localhost:1313/post/rfc-github-oauth2/</guid>
      <description>&lt;p&gt;최근 강의 준비를 위해 &lt;a href=&#34;https://tools.ietf.org/html/rfc6749&#34;&gt;RFC6749&lt;/a&gt;를 읽었다.&lt;/p&gt;&#xA;&lt;p&gt;생각보다 설명이 잘 되어 있고 읽기가 편한 편이다.&lt;/p&gt;&#xA;&lt;p&gt;시험 삼아 별도 모듈 없이 직접 node.js + express로 구현을 해 봤다. 다행히 잘 된다.&lt;/p&gt;&#xA;&lt;h2 id=&#34;인증-과정-요약&#34;&gt;인증 과정 요약&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;GitHub(Authentication Server)&lt;/strong&gt; 에서 제공하는 url을 통해 **사용자(resource owner)**는 **서비스(client)**가 scope로 미리 정의한 요청 권한을 직접 확인하고 grant한다. 결과물로 &lt;strong&gt;authorization code&lt;/strong&gt;가 나온다.&lt;/li&gt;&#xA;&lt;li&gt;서비스는 callback URL을 통해 사용자로부터 전달받은 code에 client id, secret을 함께 묶어서 인증 서버로 보내면 &lt;strong&gt;access token&lt;/strong&gt;을 얻을 수 있다.&lt;/li&gt;&#xA;&lt;li&gt;얻은 token을 이용해  &amp;lsquo;Authorization: bearer 토큰값&amp;rsquo; 헤더를 설정하고 &lt;code&gt;GET https://api.github.com/user&lt;/code&gt; 요청을 하면 정상적으로 **GitHub(resource server)**로 부터 정보를 얻을 수 있다.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;인증-과정&#34;&gt;인증 과정&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;     +----------+&#xD;&#xA;     | Resource |&#xD;&#xA;     |   Owner  |&#xD;&#xA;     |          |&#xD;&#xA;     +----------+&#xD;&#xA;          ^&#xD;&#xA;          |&#xD;&#xA;         (B)&#xD;&#xA;     +----|-----+          Client Identifier      +---------------+&#xD;&#xA;     |         -+----(A)-- &amp;amp; Redirection URI ----&amp;gt;|               |&#xD;&#xA;     |  User-   |                                 | Authorization |&#xD;&#xA;     |  Agent  -+----(B)-- User authenticates ---&amp;gt;|     Server    |&#xD;&#xA;     |          |                                 |               |&#xD;&#xA;     |         -+----(C)-- Authorization Code ---&amp;lt;|               |&#xD;&#xA;     +-|----|---+                                 +---------------+&#xD;&#xA;       |    |                                         ^      v&#xD;&#xA;      (A)  (C)                                        |      |&#xD;&#xA;       |    |                                         |      |&#xD;&#xA;       ^    v                                         |      |&#xD;&#xA;     +---------+                                      |      |&#xD;&#xA;     |         |&amp;gt;---(D)-- Authorization Code ---------&#39;      |&#xD;&#xA;     |  Client |          &amp;amp; Redirection URI                  |&#xD;&#xA;     |         |                                             |&#xD;&#xA;     |         |&amp;lt;---(E)----- Access Token -------------------&#39;&#xD;&#xA;     +---------+       (w/ Optional Refresh Token)&#xD;&#xA;&#xD;&#xA;   Note: The lines illustrating steps (A), (B), and (C) are broken into&#xD;&#xA;   two parts as they pass through the user-agent.&#xD;&#xA;&#xD;&#xA;                  Authorization Code Flow (출처: RFC6749)&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;깃헙-소스&#34;&gt;깃헙 소스&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://github.com/honux77/oauth2-node&#34;&gt;간단 예제 구현 저장소&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
  </channel>
</rss>
