<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Bfs on Honux BBS</title>
    <link>http://localhost:1313/tags/bfs/</link>
    <description>Recent content in Bfs on Honux BBS</description>
    <generator>Hugo</generator>
    <language>ko</language>
    <lastBuildDate>Tue, 17 Nov 2020 01:45:27 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/bfs/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>BOJ 9205 맥주 마시면서 걸어가기</title>
      <link>http://localhost:1313/post/boj-9205/</link>
      <pubDate>Tue, 17 Nov 2020 01:45:27 +0000</pubDate>
      <guid>http://localhost:1313/post/boj-9205/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://www.acmicpc.net/problem/9205&#34;&gt;BOJ 9205&lt;/a&gt; 는 길찾기 문제이다.&#xA;정해진 기간마다 맥주를 마시면서 걷다 맥주가 부족해지기 전에 가게에 들려 맥주를 리필하고, 목적지를 찾아갈 수 있는지 여부를 출력해주면 된다.&lt;/p&gt;&#xA;&lt;h2 id=&#34;풀이&#34;&gt;풀이&lt;/h2&gt;&#xA;&lt;p&gt;맥주가 떨어지기 전에 갈 수 있는 최대거리는 1000미터이므로 BFS를 이용해서 1000미터 이내의 슈퍼를 방문하고 목적지까지 갈 수 있는지 여부를 확인하는 방법을 풀었다.&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;using namespace std;&#xD;&#xA;&#xD;&#xA;bool canWalk(pair&amp;lt;int,int&amp;gt; &amp;amp;a, pair&amp;lt;int,int&amp;gt; &amp;amp;b) {&#xD;&#xA;    return abs(a.first - b.first) + abs(a.second - b.second) &amp;lt;= 1000;&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;void bfs(vector&amp;lt;pair&amp;lt;int,int&amp;gt;&amp;gt; &amp;amp;a) {&#xD;&#xA;    vector&amp;lt;bool&amp;gt; visited(a.size());&#xD;&#xA;    queue &amp;lt;int&amp;gt; q;&#xD;&#xA;    q.push(0);&#xD;&#xA;&#xD;&#xA;    while(!q.empty()) {&#xD;&#xA;        int curr = q.front();&#xD;&#xA;        q.pop();&#xD;&#xA;        visited[curr] = true;&#xD;&#xA;        for (int i = 1; i &amp;lt; a.size(); i++) {&#xD;&#xA;            if (!visited[i] &amp;amp;&amp;amp; canWalk(a[curr], a[i])) {&#xD;&#xA;                if (i == a.size() - 1) {&#xD;&#xA;                    cout &amp;lt;&amp;lt; &amp;#34;happy\n&amp;#34;;&#xD;&#xA;                    return;&#xD;&#xA;                }&#xD;&#xA;                q.push(i);&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;    cout &amp;lt;&amp;lt; &amp;#34;sad\n&amp;#34;;&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;int main()&#xD;&#xA;{&#xD;&#xA;    ios_base::sync_with_stdio(false);&#xD;&#xA;    cin.tie(nullptr);&#xD;&#xA;    &#xD;&#xA;    int t;&#xD;&#xA;    cin &amp;gt;&amp;gt; t;&#xD;&#xA;    while (t--) {&#xD;&#xA;        int n;&#xD;&#xA;        cin &amp;gt;&amp;gt; n;&#xD;&#xA;        &#xD;&#xA;        vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; a(n + 2);&#xD;&#xA;&#xD;&#xA;        for (int i = 0; i &amp;lt; n + 2; i++) {&#xD;&#xA;            cin &amp;gt;&amp;gt; a[i].first &amp;gt;&amp;gt; a[i].second;       &#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        bfs(a);        &#xD;&#xA;    };&#xD;&#xA;    &#xD;&#xA;    return 0;&#xD;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;회고&#34;&gt;회고&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;왜맞틀(왜 맞았는데 틀렸다고 하지?)가 나왔는데 각 테스트케이스마다 초기화를 잊었다. 실수하지 말자.&lt;/li&gt;&#xA;&lt;li&gt;BFS를 예전보다 좀 더 빠르게 구현하게 되었다. 하지만 여전히 약간씩 실수하는 경향이 있다.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;todo&#34;&gt;TODO&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;다익스트라나 플로이드-와샬로 풀어보자. 예전에는 두 알고리즘을 종종 사용했었는데, 최근에는 더 구현이 쉬운 BFS나 DFS로 풀리는 문제는 둘 중 하나로 풀 다 보니 빠른 구현이 어려워졌다.&lt;/li&gt;&#xA;&lt;li&gt;문제를 풀기 전에 복잡도를 생각해 보는 연습도 필요한 것 같다.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;다른-풀이&#34;&gt;다른 풀이&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://barefoot-coder.tistory.com/35&#34;&gt;구글링으로 나온 블로그&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
  </channel>
</rss>
